Insert Interval

//Tests
describe('insert', () => {
  it('should insert an interval into an array of arrays and merge if necessary'), => {
    let test1 = [[1,3],[6,9]];
    let interval1 = [2,5];
    let result1 = [[1,5],[6,9]];

    let test2 = [[1,2],[3,5],[6,7],[8,10],[12,16]];
    let interval2 = [4,8];
    let result2 = [[1,2],[3,10],[12,16]];

    expect(insert(test1)).toEqual(result1);
    expect(insert(test2)).toEqual(result2);
  });
});

//Procedure Space/Time Complexity: O(1)/O(log n)
Binary Search to position using the start date as target and searching through end dates. If target is less than or equal to the last end date found then the interval needs to be merged with the found interval. 

When position is found
- Find next start time that is greater than interval to insert's end time and count the arrays skipped.
- Delete merged arrays and insert new array


//Can we do better?
So far no. Search is the only practical place of optimization and it seems impossible to get a O(1) search.

//Solution Attempt
/**
 * @param {number[][]} intervals
 * @param {number[]} newInterval
 * @return {number[][]}
 */
var insert = function(intervals, newInterval) {
  let position = 0;
  let mergeStart = false;

  let search = target => {
    let start = 0;
    let end = intervals.length - 1;

    while(start < end) {
      position = start + Math.floor(end - start) / 2);

      if(interval[position] === target) {
        mergeStart = true;
        break;
      } else if(intervals[position][1] > target) {
        end = position;
      } else if(intervals[position][1] < target) {
        start = position;
      }
    }

    if(!mergeStart) {
      if(intervals[position][1] >= target && target >= intervals[position][0]) {
        mergeStart = true;
      }
    }

  };

  let insertInterval = () => {
      search(newInterval[0]);

      let start = mergeStart ? intervals[position][0] : newInterval[0];
      let end;
      let i = position;

      while(i < intervals.length) {
        if(intervals[i - 1][1] < newInterval[1] && newInterval[1] < intervals[i][0]) {
          i--;
          end = newInterval[1];
          break;
        } else if(intervals[i][0] <= newInterval[1] && newInterval[1] <= intervals[i][1]) {
          end = intervals[i][1];
          break;
        } else if(i === intervals.length - 1) {
          end = newInterval[1];
        }

        i++;
      }

      intervals.splice(position, position - i, [start, end]);
  };

  insertInterval();
  return intervals;    
};